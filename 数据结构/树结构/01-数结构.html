<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>树结构</title>
</head>
<body>
  <script>
    //  封装二叉搜索树
    class BinarySearchTree {
      constructor () {
        //  初始化根节点
        this.root = null;
        //  实例化节点
        this.Node = function (key) {
          return {
            key,
            left: null,
            right: null
          }
        }
      }

      /**
       * 插入数据：对外给用户调用的方法
       * @param { Number } key
       */
      insert (key) {
        //  1.根据key创建节点
        let newNode = new this.Node(key);
        //  判断是否是根节点
        if (this.root === null) {
          this.root = newNode;
        } else {
          this.insertNode(this.root, newNode);
        }
      }

      /**
       * 递归添加节点
       * @param { Object } node
       * @param { Object } newNode
       */
      insertNode (node, newNode) {
        if (newNode.key < node.key) {//  向左查找
          if (node.left == null) {//  1.当左子数没有值
            node.left = newNode;
          } else {//  2.当左子数有值，
            this.insertNode(node.left, newNode);
          }
        } else {//  向右查找
          if (node.right == null) {
            node.right = newNode;
          } else {
            this.insertNode(node.right, newNode);
          }
        }
      }

      /**
       * 先序遍历
       * @param { Function } handler
       */
      preOrderTraversal (handler) {
        this.preOrderTraversalNode(this.root, handler);
      }

      /**
       * 先序遍历递归调用
       * @param { Object } node
       * @param { Function } handler
       */
      preOrderTraversalNode (node, handler) {
        if (node !== null) {
          //  1.打印当前经过的节点
          handler(node.key);
          //  2.遍历所有的左子节点
          this.preOrderTraversalNode(node.left, handler);
          //  2.遍历所有的右子节点
          this.preOrderTraversalNode(node.right, handler);
        }
      }

      /**
       * 中序遍历
       * @param { Function } handler
       */
      midOrderTraversal (handler) {
        this.midOrderTraversalNode(this.root, handler);
      }

      /**
       * 递归遍历
       * @param { Object } node
       * @param { Function } handler
       */
      midOrderTraversalNode (node, handler) {
        if (node !== null) {
          this.midOrderTraversalNode(node.left, handler);
          handler(node.key);
          this.midOrderTraversalNode(node.right, handler);
        }
      }

      /**
       * 最小值
       * @return value
       */
      min () {
        const result = this.minNode(this.root)
        return result !== null ? result.key : null;
      } 
      minNode (node) {
        if (node === null) {
          return node;
        }
        while (node && node.left !== null) {
          node = node.left;
        }
        return node;
      }

      /**
       * 最大值
       * @return value
       */
       max () {
        const result = this.maxNode(this.root)
        return result !== null ? result.key : null;
      } 
      maxNode (node) {
        if (node === null) {
          return node;
        }
        while (node && node.right !== null) {
          node = node.right;
        }
        return node;
      }

      /**
       * 查找节点
       * @param { Number } key
       * @return { Boolean } true/false
       */
      search (key) {
        return this.searchNode(this.root, key);
      }
      /**
       * 递归
       * @param { Object } node
       * @param { Number } key
       */
      searchNode (node, key) {  
        if (node === null) {//  根节点为空
          return false; 
        } else if (node.key == key) {// 传入值等于根节点
          return true;
        } else if (key < node.key) {//  传入值小于根节点
          return this.searchNode(node.left, key);
        } else {//  传入值大于根节点
          return this.searchNode(node.right, key);
        }
      }

      /**
       * 循环
       * @return true/false
       */
      // search (key) {
      //   let node = this.root;
      //   while (node !== null) {
      //     if (key < node.key) {
      //       node = node.left;
      //     } else if (key > node.key) {
      //       node = node.right;
      //     } else {
      //       return true;
      //     }
      //   }
      //   return false;
      // }

    }

    //  插入测试
    let a = new BinarySearchTree()
    a.insert(11)
    a.insert(7)
    a.insert(5)
    a.insert(9)
    a.insert(15)
    a.insert(13)
    a.insert(20)
    console.log(a);

    //  测试先序遍历
    let resString = '';
    a.preOrderTraversal((key) => {
      resString += key + " ";
    })
    console.log(resString); //11 7 5 9 15 13 20

    //  测试中序遍历
    resString = ''
    a.midOrderTraversal((key) => {
      resString += key + " ";
    })
    console.log(resString);//5 7 9 11 13 15 20
    console.log(a.min());//5
    console.log(a.max());//20
    console.log(a.search(5));//true
  </script>
</body>
</html>